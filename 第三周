第三周（11.5-11.11）


学习内容：

C语言程序设计进阶：指针的使用，指针运算；
数据结构：基本概念，线性表；



问题和总结：

1.C语言中%d,%p,%o，%x的意义：

答：格式说明由“％”和格式字符组成，如％d％f等。它的作用是将输出的数据转换为指定的格式输出。格式说明总是由“％”字符开始的。不同类型的数据用不同的格式字符。
格式字符有d,o,x,u,c,s,f,e,g等。
如：
％d整型输出，％ld长整型输出，
%p 输出变量的内存地址，
％o以八进制数形式输出整数，
％x以十六进制数形式输出整数，


2.“指针”和“指针变量”的区别：

答：一个变量的指针是它的地址，通过指针找到以它为地址的内存单元（p）；
指针变量是用来存放另一个变量的地址的，指针变量的值是具有实际值的变量的地址（*p）。


3.指针在声明和使用时的区别：

答：c语言指针的操作分为：指针声明，指针的使用。
指针声明：在使用指针之前需要先对指针进行声明，确定指针的类型。
例如：int *ptr。
在声明这个过程中，*表示ptr是一个指针变量，*表示地址。
指针的使用：
例如：int var=3;
         ptr=&var;//这时ptr=var的地址
         printf("value of ptr:%d",*ptr);//这里*ptr=ptr指向的地址中存储的值，即var的值。结果是*ptr=3

总结：在声明中，*ptr是一个地址；在使用中，*ptr是取(地址ptr中的)内容.


4.指针常量和常量指针：

答：指针常量——指针类型的常量（int *const p）
本质上一个常量，指针用来说明常量的类型，表示该常量是一个指针类型的常量。在指针常量中，指针自身的值是一个常量，
不可改变，始终指向同一个地址。在定义的同时必须初始化。
int a = 10, b = 20;
int * const p = &a;
*p = 30; // p指向的地址是一定的，但其内容可以修改

常量指针——指向“常量”的指针（const int *p， int const *p）
常量指针本质上是一个指针，常量表示指针指向的内容，说明该指针指向一个“常量”。在常量指针中，指针指向的内容是不可改变的，指针看起来好像指向了一个常量。
int a = 10, b = 20;
const int *p = &a;
p = &b; // 指针可以指向其他地址，但是内容不可以改变


5.数组变量和指针的关系：

老师说数组变量可以被看作是const的指针变量，到底是“可以被看作”，还是“就是”指针呢？

用程序证据来说明你的观点。

（提示：如果对const指针的所有的操作都可以对数组变量做，而且结果一致，就说明数组变量就是指针；如果有某个操作不能做，或者结果不一致，就说明不是指针）

    #include <stdio.h>
    int main(){
        int a[] = {1,1,2,3,4,5,6,7,8,9,0,};
        int *const p = &a[0];

        printf("sizeof(a) = %d , sizeof(p) = %d \n",sizeof(a) , sizeof(p));
            //sizeof(a)显示为44，是数组整个的一个长度，sizeof(p)显示为8； 是指针的长度 
        printf("main:p = %p\n",p);
        printf("main:a = %p\n",a);
            //在主函数中仍然是数组的首地址 
        a[13] = 10;
        printf("main:a[13] = %d\n",a[13]); 
        p[13] = 10;
        printf("main:p[13] = %d\n",p[13]);
        //在主函数中都可以顺利执行 
        sum(a , 11);
    } 

    int sum(int a[],int len){
        int sum = 0;
        int i = 0; 
        int *const p = &a[0];
    //    int *const a = &a[0]; //[Error] 'a' redeclared as different kind of symbol （a 重新声明为不同类型的符号） 
    //    int *const p = &a[0]; //[Error] redefinition of 'p'                          （p重复定义） 
        //上面两个提示的是不同的错误， 说明数组参数实际上不是常量指针这个类型
    //    int * a = &a[0];  26    //[Error] 'a' redeclared as different kind of symbol
    //    int *const p = &a[0];   //[Error] redefinition of 'p'
        //说明数组参数也不是指针 
        printf("p = %p\n",p);
        printf("a = %p\n",a);
        //他两指向的是一个数组
        p[1] = 10;
        printf("p[1] = %d\n",p[1]);
        a[1] = 10; 
        printf("a[1] = %d\n",a[1]);
        //上面无论执行哪个都是一样的，而且都可执行，这说明在修改变量，访问变量上是相同的
        a[13] = 10;
        printf("a[13] = %d\n",a[13]); 
        p[13] = 10;
        printf("p[13] = %d\n",p[13]);
        //这说明a也并没有存储关于他的长度的信息，它仅仅是一个地址，和p一样，两个都没有警告，可以编译出相同的结果


        for(i = 0;i < len;i++){
            sum += a[i];
        }
        printf("sizeof(a) = %d  \n",sizeof(a) ); 
        //通过编译看以看到sizeof(a)仍然是8，从这点看，传递的数组参数确实和常量指针一样 
        return sum;
    }
    //从上面的测试来看，当数组变量作为参数时，它不是严格意义上的指针，更不是常量指针，但是他可以被看做指针，而且常量指针的操作都可以作用于数组变量
    //当数组变量不是参数时，即它在主函数中，它有两层含义 ，在用在sizeof上时，它似乎被看做了一个数组整体，但是其他情况下，都可以被当做常量指针。
    
    
6.malloc函数分配内存失败的原因：
答：①内存不足。
    ②在前面的程序中出现了内存的越界访问，导致malloc()分配函数所涉及的一些信息被破坏。下次再使用malloc()函数申请内存就会失败，返回空指针NULL(0)。


7.该程序出错的原因：
    char *p;
    while (1) {
         p = malloc(1);
        *p = 0;
     }
答：这个循环是死循环，在malloc没内存分配的时候会返回空指针，没有权限修改0内存地址，程序不会分配给我0内存地址的空间，所以报错。


8.malloc分配的地址为什么有时连续有时不连续？
