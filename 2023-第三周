进度
●数据结构：希尔排序
●蓝桥杯题库：门牌制作，卡片，数字三角形，杨辉三角形，成绩分析，空间
下周规划
●继续刷数据结构的课和题
●看蓝桥杯真题讲解的回放

问题
●动态规划的经典题数字三角形，做的时候有个问题，为什么是只判断下一层中最大的，如果另一条路径下一层小，但是总和更大，这个方法会有问题吗？

●杨辉三角形的check函数为什么这么写？
（具体查图片，更清晰）
int check(int k)//check使用斜二分查找/*下面解决的问题是:确定了从第k斜行开始检查，我该从该斜行的哪一行开始寻找n?定义:r是要找的数n的行号，k是斜行的序号(也是n的列号)，L是该斜行的第一个数的行数*ll l、 r. mid:1 = 2*k;//比如第16斜行的第一个数的行数是32，L就是32，L就是检查的起点r =max(n,1);/*第二斜行是正整数序列，举个例子:我要查找10，然后第10行的第二个(也就是处于第二斜行上)是10,我肯定能找到它，不需要往下检查了，但是这并不是第一次出现10,10在第5行就出现过了，能确定的是 10第一次出现的行数一定≤10推广以后:我要查n，最多查到第n行就行。而L是最小行数，正常情况L肯定比n小,那可以直接写r=n吗?不可以，因为n是你输入的东西，n可能为负数可能为0。我觉得应该改成:if (n<1)
cout<<"不存在"<<endl;
else
r=n.还有原注解的C(n,2)=n是错误式子，应该是C(n，1) =n，第二斜行是C (n，1)，第三斜行是C (n，2)(原文):边界取n是因为一定存在C(n,2)=n此时在第二斜行，第二斜行有从1开始的所有整数*/
while (r >1) //能进入循环说明r>L也就是上面取的是r=n。
int mid =(1+ r) / 2;//第一次的时候，1是最小行数，r=n是最大行数，mid的值是取对半if(C(mid，k)>= n)/*第i行第j列的值是C(i，j)。若第mid行第k列的数比n大，说明n可能在第mid行里面，所以先让行数r=mid*/
r = mid;
else 1 = mid .l;/*反之，若这一行的数比n小，那我让L变大，因为mid = (L+ r)/ 2，L变大了则mid变大，mid往下一行，C(mid，k)也变大了，如果满足>= n就说明n可能在第mid行，r就有落脚点了*/}/*假如第一次就成功r=mid，因为mid是大于L的，还会继续循环，相当于mid一直取对半，r又等于mid，r越来越接近那个唯一确定的行数。取对半的好处是，假如我要找999999，而L初始是32，对半以后mid变成500015，如果n不在第500015行，L就变成500016，你可以发现L从32跃到了500016，对半取是很快的，不用一行一行加。。。*/
//循环结束，得到了唯一确定的r值
if (c(r，k) != n)/*看看c(r，k)是不是要找的n值，结果不是,从main函数可以知道这个斜行的检查结束了，去检查下一个斜行*
return 0:
else
printf("%lld"，(r +1)*r /2+k +1):/*找到了，(r + 1) * r / 2 + k + 1是计算要找的数是第几个*/return 1;n
int main0
scanf("%d",&n)://i取16是因为C(34,17)已经超过题目中n的范围for (int i = 16; ;i--) {if (check(i))break;
return 0;

●内存的换算：
一般内存换算是1024进制，也就是2的10次方。 1TB=1024GB 1GB=1024MB 1MB=1024KB 1KB=1024Byte 1Byte=1024Bit

代码练习：
杨辉三角形https://github.com/Tychoool/others/blob/main/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2.cpp
卡片：https://github.com/Tychoool/others/blob/main/%E5%8D%A1%E7%89%87.cpp
