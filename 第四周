第四周（11.12-11.18）


学习内容：

c语言程序设计：指针与字符串，ACLLib的基本图形函数



问题与总结：

1.scanf()函数的原理和scanf中有\n的问题：

（转自https://blog.csdn.net/weiweicsdn1/article/details/52185453）
答：程序执行到scanf时，会从你的缓冲区读东西，如果缓冲区是空的，就阻塞住，等待你从键盘输入。
scanf对不同的参数表现出来的特性不一样。如果程序员使用了scanf("%c",..)，那他就有必要知道这函
数能把回车符读出来。

当执行scanf("%s",name)的时候，要求你从键盘输入，于是你输入了"abc"，然后“回车”。缓冲区里自然
而然地是：abc\n。scanf把abc拿走了，留下了\n，缓冲区里现在就剩下\n于是，下一个scanf ("%c",&s
ex); 想当然地读取了\n。

- 关于scanf忽略前导空白符这一点，可以这样验证：
写个程序，用scanf()读数据，只要不是%c就行。然后输入的时候，随便输入回车、空格、制表符，然后“
回车”确认。会发现程序依然提示等待你输入。就是因为它忽略掉所有前导空白符之后发现缓冲区是空的！
于是阻塞住，等待你输入。

*关于scanf是直到看见空白符结束读取这一点，程序里如果我们想一次读入一个英文句子:I am a stude
-nt.如果你用scanf读的话，只能读出"I"，想读出后面的东西要不断调scanf。此时需要用gets，这个函
数不管是什么一律读进来，直到遇到回车符才停下。总之，各有各的用途，全都熟悉之后，才能在恰当的
时候恰当地使用。

scanf中\n问题-------------------------------------------------------------------------

scanf("%d\n",&num);

scanf函数的第一个参数指定了后面变量读取的格式，这样写的话会按照 ：
数字 回车
的格式读取，读到回车之后会继续读下一行，如果缓冲区没有东西scanf就会阻塞在那里，直到用户有输入
以至于有时候会遇到再输入一行才能有返回的情况。


2.指针什么时候加*什么时候不需用加，分别代表什么含义？

（参考https://blog.csdn.net/weixin_33781606/article/details/93079648，
https://blog.csdn.net/qq_44358197/article/details/90704684）

答：按照我个人的理解指针的二值分别就是指指针存储的值和指针指向的值，我们都知道，我们经常说的指针
实际上是指指针变量，那么变量就有存储的指，只不过指针比较特殊，是用来存储地址的变量，这就是指针二
值之一，既然指针变量存储了变量的地址，那么就可以通过存储的地址值就可以找到指向的值。

*是用来声明指针的那么当声明了一级指针后，p就是指针变量的名字，代表一个空间，用来存储地址的变量，
那么p就是指针变量存储的值，*p就是指向的值，对一级指针是这样，对多级指针以此类推。


多级指针含义：

指针可以指向一个普通类型的变量，例如int、double、char等，也可以指向一个指针类型的变量，如int*、
double*、char*等。如果一个指针指向的是另一个指针，我们就成他为二级指针，或者指向指针的指针。
将这种关系转换为C语言代码：

int a=100;
int *p1=&a;
int **p2=&p1;

指针变量也是一种变量，也会占用内存空间，也可以用&来获取它的指针。C语言不限定指针的级数，没增加
一级指针，在定义指针变量时就得增加一个*号。p1是一级指针，指向普通类型的数据，定义时有一个*；p2
是二级指针，指向一级指针p1，定义时又两个*。

如果我们希望再定义一个三级指针p3，让它指向p2，那么可以这样写：

int ***p3=&p2;

四级指针同理。实际指针经常会使用一级和二级指针，几乎不会用到高级指针。

通过指针的指针，不仅可以访问它指向的指针，还可以访问它指向的指针所指向的数据。想要获取指针指向的
数据时，一级指针加一个*，二级指针加两个*，三级指针加三个*，以此类推。


3.char *字符串和char []字符串的理解：

（https://www.cnblogs.com/maider/p/11138910.html）

答：一、char* 字符串

　　（1）如何声明一个char*字符串

你可以这样：

　　char* str = "test";　　//str是一个指针，存放在栈区，"test"是一个常量，存放在常量区，VS2017要
  求这句声明前面必须加上const，因为它所指向的常量字符串是不可更改的

　　delete str;

还可以这样：

　　char* str = new char[20];　　//str是一个指针，存放在栈区，指向堆区的一块20个字节的区域的首地址

　　strcpy(str, "qwewqe");　　//对其进行赋值

　　delete str;

还可以这样：

　　char* str =new char[20] { 'a' };　　//直接将字符串内所有的元素都设为字符 'a'

　　delete str;

或者这样：

int main()
{
    int a;
    a = 10;
    char * arr = new char[a];
    cin.getline(arr, a);//最多读a个字符，如果提前遇到换行符，会立即停止
    cout << arr << endl;
    return 0;
}

　　（2）如何声明一个char []字符串

你可以这样：

　　char cat[4] = {'T', 'O', 'M', '\0'};　　//如果最后一个字符不是 '\0' ，那么cat就只是一个字符
  数组，而不是字符串了

　　delete [] cat;

还可以这样：

　　char cat[4] = "cat";　　//注意字符数是3，而cat的大小是4

或者这样：

　　char cat[] = "cat";　　//让编译器自动判断大小

int main()
{
    char cat[] = "cat";
    cout << sizeof(cat) / sizeof(cat[0]) << endl;//4，这里没有length()或者size()方法计算元素个数
    return 0;
}
[]内如果要限定大小，只能用const size_type，包括字面值。

　　(3)两者之间的区别

1)变量加减运算

int main()
{
    char* str = "test";
    char cat[4] = "cat";
    str++;
    cout << str << endl;//est
    cout << str[0] << endl;//e
    return 0;
}

str++是合法的，而cat不能这样操作，因为它是数组名。

2)写权限

上述代码中，str[1]不能放在赋值号的左边，而cat[1]可以。

3)用char[]初始化char *

int main()
{
    char cat[] = "cat";
    char* str = cat;
    cout << str << endl;//cat
    return 0;
}


4.字符串输入的三种方式:

https://blog.csdn.net/Qxiaofei_/article/details/122142431

一、gets()
该函数原型为：

# include <stdio.h>
char *gets(char *str);
1
2
gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间

# include <stdio.h>
int main(void)
{
	char a[256] = {0};
	gets(a);
	printf("%s",a);
    return 0;
}

二、getchar()
# include <stdio.h>
int main(void)
{
	int i=0;
	int j;
	char ch;
	char a[256] = {0};
	while((ch=getchar())!='\n')//一直接收缓冲区的字符。直至收到回车
	{
	   	a[i]=ch;
	   	i++;
	}
	a[i]='\0';    //加上串尾符
	for(j=0;j<i;j++)
	{
		printf("%c",a[j]);
	}
    return 0;
}

三、scanf()
# include <stdio.h>
int main(void)
{
	char a[256];
	scanf("%s",&a);
	printf("%s",a);
    return 0;
}


注：

1）canf这种格式串不能接收带空格的字符串，比如输入"abc 123 678"的话，字符串只会接收到abc，遇空格就结束。

2）使用 gets() 时，系统会将最后“敲”（Enter）的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符；
而使用scanf时，最后的“敲”会遗留在缓冲区中，如果使用scanf，则需要使用gerchar（）将缓冲区的Enter吃掉。换成
scanf后，只敲了一次回车就结束程序，可知scanf情况下缓冲区有残留Enter。加入getchar()即可解决残留Enter问题。


5.getchar()的返回类型为什么是int？

https://blog.csdn.net/weixin_30438795/article/details/117124493

答：1)getchar()除了返回正常的字符外，还会返回输入结束符EOF(end of file);
2)EOF通常在文件中被定义为-1;
3)各种数据类型能表示的数值范围由编译器决定。char类型在有些编译器中定义的范围为0~255，另外一些编译器中定义的范
围为-128~127。当编译器中定义的范围为0~255时，用char接收getchar()返回值时就会出错。
4)int改为char后能在我的电脑上正常编译，时由于我的编译器中定义的范围为-128~127，当用char接收时会隐式的转化为
char类型。
5)即使编译器总定义的范围为-128~127，程序也有可能出错。虽然常见字符到127位就结束了。但是ASCII表中分配到的时256。
128~256为拓展字符，如常用的欧元符号等均在内。

综上：getchar()返回的内容用更大范围区间的int型接收，才能使程序更加稳健。
